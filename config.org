* ELPA configuration
Add additional archives and do (package-initialize)
#+begin_src emacs-lisp :results silent
  (require 'package)
  (add-to-list 'package-archives
               '("marmalade" . "http://marmalade-repo.org/packages/"))
  (package-initialize)
#+end_src

* el-get configuration
This code is modified from
emacs-kicker(https://github.com/dimitri/emacs-kicker). It can install
el-get automatically synchronously if we don't have installed it yet.

#+begin_src emacs-lisp :results silent
  (setq el-get-dir (file-name-as-directory (locate-user-emacs-file "el-get")))
  (add-to-list 'load-path (abaw/join-path el-get-dir "el-get"))

  (unless (require 'el-get nil t)
    (with-current-buffer (url-retrieve-synchronously "https://github.com/dimitri/el-get/raw/master/el-get-install.el")
      (let (el-get-master-branch)
        (end-of-buffer)
        (eval-print-last-sexp))))
#+end_src

** Addtional local recipes
*** color-moccur and moccur-edit
#+begin_src emacs-lisp :results silent
  (add-to-list 'el-get-sources
               '(:name color-moccur
                       :type emacswiki
                       :website "http://www.emacswiki.org/emacs/color-moccur.el"
                       :features "color-moccur"))
  (add-to-list 'el-get-sources
               '(:name moccur-edit
                       :type emacswiki
                       :website "http://www.emacswiki.org/emacs/moccur-edit.el"
                       :features "moccur-edit"
                       :depends color-moccur))
#+end_src

* Basic Configuration
** enabled advanced features
#+begin_src emacs-lisp :results silent
(put 'narrow-to-region 'disabled nil)
#+end_src

** a minor mode for my global key bindings
According to scottfrazer's brilliant idea, we can use a minor mode for
defining global key bindings to prevent our key bindings overriden by
other major modes. See
http://stackoverflow.com/questions/683425/globally-override-key-binding-in-emac.

#+begin_src emacs-lisp :results silent
  (defvar my-global-keys-mode-map (make-sparse-keymap))
  (define-minor-mode my-global-keys-mode
    "A minor mode used to define my global key bindings"
    :global t
    :keymap 'my-global-keys-mode-map)

  (defvar my-global-keys--keymap-alist '(my-global-keys-mode my-global-keys-mode-map))
  (push 'my-global-keys--keymap-alist emulation-mode-map-alists)
  (my-global-keys-mode 1)

  (defun abaw/global-set-key (key command)
    "The same as `global-set-key' except the key bindings
    configured by this will not be overriden by other major
    modes."
    (interactive "KSet key globally: \nCSet key %s to command: ")
    (or (vectorp key) (stringp key)
        (signal 'wrong-type-argument (list 'arrayp key)))
    (define-key my-global-keys-mode-map key command))
#+end_src

** dired
Let dired do some recursive operations
#+begin_src emacs-lisp :results silent
(setq dired-recursive-copies 'top)
(setq dired-recursive-deletes 'top)
#+end_src
use dired+
#+begin_src emacs-lisp :results silent
(el-get 'sync "dired+")
#+end_src

** show column numbers
#+begin_src emacs-lisp :results silent
(column-number-mode 1)
#+end_src

** enlarge the kill ring
#+begin_src emacs-lisp :results silent
(setq kill-ring-max 200)
#+end_src

** yes/no => y/n
#+begin_src emacs-lisp :results silent
(fset 'yes-or-no-p 'y-or-n-p)
#+end_src

** better scrolling
#+begin_src emacs-lisp :results silent
(setq scroll-margin 3 scroll-conservatively 100)
#+end_src

** set default fill-column
#+begin_src emacs-lisp :results silent
(set-default 'fill-column 80)
#+end_src

** utf-8 environment
But I don't know if this is good enough?? Do I need to set-keyboard-coding-system??
#+begin_src emacs-lisp :results silent
(set-language-environment 'utf-8)
#+end_src

** show trailing white spaces by default and disable it in some modes
#+begin_src emacs-lisp :results silent
  (setq-default show-trailing-whitespace t)
  (add-hook 'comint-mode-hook
            (lambda () (setq show-trailing-whitespace nil)))
#+end_src

** highlight matching parens
#+begin_src emacs-lisp :results silent
(show-paren-mode t)
#+end_src

** rectangle selection using cua-mode
   This also remaps a lot of key bindings of commands. Here are some
   examples:
     - set-mark-command -> cua-set-mark
     - yank, clipboard-yank, x-clipboard-yank -> cua-yank
     - exchange-point-and-mark -> cua-exchange-point-and-mark
       exchange point and mark without activating the region.
#+begin_src emacs-lisp :results silent
(cua-mode t)
(setq cua-enable-cua-keys nil)
#+end_src

** ibuffer
#+begin_src emacs-lisp :results silent
  (require 'ibuffer)
      (abaw/global-set-key (kbd "C-x C-b") 'ibuffer)
      (setq ibuffer-saved-filter-groups
            (quote (("default"
                     ("Org"
                      (mode . org-mode))
                     ("Version Control Systems"
                      (mode . magit-mode))
                     ("Programming"
                      (or
                       (mode . c-mode)
                       (mode . c++-mode)
                       (mode . perl-mode)
                       (mode . python-mode)
                       (mode . lisp-mode)
                       (mode . emacs-lisp-mode)
                       (mode . haskell-mode)
                       ))))))
      (add-hook 'ibuffer-mode-hook
                (lambda ()
                  (ibuffer-switch-to-saved-filter-groups "default")))



#+end_src

** I want more spaces
#+begin_src emacs-lisp :results silent
  (scroll-bar-mode -1)
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (fringe-mode 0)
#+end_src

** Here configures some global key bindings
#+begin_src emacs-lisp :results silent
  (abaw/global-set-key (kbd "C-c r") 'font-lock-fontify-buffer)
  (abaw/global-set-key (kbd "C-2") 'set-mark-command)
  (abaw/global-set-key (kbd "C-c g") 'goto-line)
  (abaw/global-set-key (kbd "M-/") 'hippie-expand)
#+end_src

** ido
#+begin_src emacs-lisp :results silent
  (require 'ido)
  (ido-mode t);
  (setq read-file-name-function 'ido-read-file-name)
  (setq ido-enable-flex-matching t)
  (setq ido-max-directory-size nil)

  ;; (setq ido-default-buffer-method 'selected-window)
  ;; (setq ido-default-file-method 'selected-window)
#+end_src

** zenburn color theme
#+begin_src emacs-lisp :results silent
  (el-get 'sync "zenburn-theme")
  (message "custom-theme-load-path=%s" custom-theme-load-path)
  (load-theme 'zenburn t)
#+end_src

** color-moccur
#+begin_src emacs-lisp :results silent
  (el-get 'sync "moccur-edit")
  (require 'moccur-edit)
#+end_src

** yasnippet
Some of my snippets need time-stamp package
#+begin_src emacs-lisp :results silent
  (require 'time-stamp)
#+end_src

Enable yasnippet
#+begin_src emacs-lisp :results silent
  (el-get 'sync "yasnippet")
  (yas/global-mode t)
  (setq yas/snippet-dirs (abaw/join-path abaw/top-dir "snippets"))
  (yas/load-directory yas/snippet-dirs)

  ;; if we use setq, the default "TAB" key will not be unbind.
  (custom-set-variables '(yas/trigger-key "<C-tab>"))
#+end_src

** C-./C-, fast jump to temporarily saved place
These code are modified from someone's .emcas.el.
#+begin_src emacs-lisp :results silent
  (defun ska-point-to-register()
    "Store cursorposition _fast_ in a register.
  Use ska-jump-to-register to jump back to the stored position."
    (interactive)
    (point-to-register 8))

  (defun ska-jump-to-register()
    "Switches between current cursorposition and position
  that was stored with ska-point-to-register."
    (interactive)
    (let ((tmp (point-marker)))
      (jump-to-register 8)
      (set-register 8 tmp)))

  (abaw/global-set-key (kbd "C-.") 'ska-point-to-register)
  (abaw/global-set-key (kbd "C-,") 'ska-jump-to-register)

#+end_src

** wrap long time
#+begin_src emacs-lisp :results silent
(set-default 'truncate-lines nil)
(setq truncate-partial-width-windows nil)
#+end_src

** limit maximum size for comint-mode(e.g. shell-mode)
#+begin_src emacs-lisp :results silent
(add-to-list 'comint-output-filter-functions 'comint-truncate-buffer t)
(setq comint-buffer-maximum-size 20000)
#+end_src

** auto-complete
#+begin_src emacs-lisp :results silent
  (el-get 'sync "auto-complete")
  (abaw/global-set-key (kbd "C-`") 'auto-complete)
  (require 'auto-complete-config)
  (global-auto-complete-mode 1)
  (setq ac-auto-start nil)
#+end_src

** store backup file in user-emacs-directory
#+begin_src emacs-lisp :results silent
  (setq backup-directory-alist `(("." . ,(abaw/join-path user-emacs-directory "backup"))))

#+end_src

** winner mode
#+begin_src emacs-lisp :results silent
(winner-mode 1)
#+end_src

** smex mode
#+begin_src emacs-lisp :results silent
  (el-get 'sync "smex")
  (abaw/global-set-key (kbd "M-x") 'smex)
  (abaw/global-set-key (kbd "C-c M-x") 'execute-extended-command)
#+end_src
** helm
#+begin_src emacs-lisp :results silent
  (el-get 'sync "helm")
  (require 'helm-config)
  (abaw/global-set-key (kbd "<f5>") 'helm-for-files)
  (setq helm-for-files-preferred-list '(helm-c-source-files-in-current-dir
                                        helm-c-source-buffers-list
                                        helm-c-source-recentf))
#+end_src

** switch window using arrow keys
#+begin_src emacs-lisp :results silent
  (require 'windmove)
  (abaw/global-set-key (kbd "C-x <up>") 'windmove-up)
  (abaw/global-set-key (kbd "C-x <down>") 'windmove-down)
  (abaw/global-set-key (kbd "C-x <left>") 'windmove-left)
  (abaw/global-set-key (kbd "C-x <right>") 'windmove-right)
#+end_src

** insert/replace a file name at point
#+begin_src emacs-lisp :results silent
  (defun abaw/insert-or-replace-filename-at-point ()
    "The command will insert or replace filename at current point
  using read-file-name interface"
    (interactive)
    (let ((filename-region (bounds-of-thing-at-point 'filename))
          (filename (read-file-name "File name to insert:")))
      (when (and filename (not (equal filename "")))
        (when filename-region
          (delete-region (car filename-region) (cdr filename-region)))
        (insert filename))))
#+end_src


* Configuraton for org mode
** org mode helper functions/commands
#+begin_src emacs-lisp :results silent
  (defun abaw/org-src-split ()
    "Split an org source block into two blocks at point. If a
  region has been marked, it splits a org source block into three
  blocks."
    (interactive)
    (let ((head (org-babel-where-is-src-block-head))
          headline)
      (unless head
        (error "Point is not inside a source block"))

      (setq headline (save-excursion
                       (goto-char head)
                       (end-of-line)
                       (buffer-substring-no-properties head (point))))

      (flet ((split-at-pos (pos)
                           (goto-char pos)
                           (beginning-of-line)
                           (insert (format "#+end_src\n%s\n" headline))))

        (if (region-active-p)
            (progn
              (split-at-pos (save-excursion
                              (goto-char (region-end))
                              (if (bolp)
                                  (point)
                                (1+ (line-end-position)))))
              (split-at-pos (region-beginning)))
            (split-at-pos (point))))))

#+end_src

** Some basic configurations
Key bindings for org mode:
#+begin_src emacs-lisp :results silent
  (abaw/global-set-key (kbd "<f12>") 'org-agenda)
  (abaw/global-set-key (kbd "C-S-r") 'org-capture)
#+end_src
spell checking in the org buffers
#+begin_src emacs-lisp :results silent
  (add-hook 'org-mode-hook
	    #'(lambda ()
		(flyspell-mode t)))
#+end_src
highligh current line in agenda buffers:
#+begin_src emacs-lisp :results silent
  (add-hook 'org-agenda-mode-hook (lambda () (hl-line-mode)))
#+end_src
highlights in sparse tree persists after buffer being modified
#+begin_src emacs-lisp :results silent
(setq org-remove-highlights-with-change nil)
#+end_src

** Todo state related configuration
todo keyword settings
#+begin_src emacs-lisp :results silent
  (setq org-todo-keywords
        '((sequence "MAYBE(m)" "TODO(t)" "STARTED(s)" "WAITING(w)" "POSTPONED(p)" "|" "DONE(d)" "CANCELLED(c)" "DELEGATED(D)" )))
#+end_src
todo state trigger
#+begin_src emacs-lisp :results silent
(setq org-todo-state-tags-triggers
	'((done ("DONE" . t) ("STARTED" . t))
	  ("TODO" ("STARTED"))
	  ("MAYBE" ("STARTED"))
	  ("STARTED" ("STARTED" .t))
	  ("WAITING" ("STARTED" .t))))
#+end_src

I want to change todo state to STARTED while clocking in a todo entry which is
not started yet. This could be achieved by using a this hook:
#+begin_src emacs-lisp :results silent
  (defun abaw/org-update-state-for-current-clock-entry ()
    "Updates the todo state to \"STARTED\" if current clock entry
      is a todo entry and in state \"TODO\" or \"MAYBE\". "

    (unless (org-clocking-p)
      (error "not current clocking entry"))

    (save-excursion
      (save-window-excursion
        (org-clock-goto)
        (let ((state (org-get-todo-state)))
          (when (and state (member state '("TODO" "MAYBE")))
            (org-todo "STARTED"))))))

  (add-hook 'org-clock-in-hook 'abaw/org-update-state-for-current-clock-entry)

#+end_src





* Configurations for version control systems
** p4
#+begin_src emacs-lisp :results silent
  (when (shell-command "which p4")
    (require 'p4))
#+end_src


** git
#+begin_src emacs-lisp :results silent
(el-get 'sync "magit")
#+end_src
*** run magit-status in fullscreen and restore window configuration afterwards. This is copied from "what the emacs.d!?" site.
#+begin_src emacs-lisp :results silent
(require 'magit)
(defadvice magit-status (around magit-fullscreen activate)
  (window-configuration-to-register :magit-fullscreen)
  ad-do-it
  (delete-other-windows))

(defun magit-quit-session ()
  "Restores the previous window configuration and kills the magit buffer"
  (interactive)
  (kill-buffer)
  (jump-to-register :magit-fullscreen))

(define-key magit-status-mode-map (kbd "q") 'magit-quit-session)
#+end_src


* Programming languages
** lisp
*** turn paredit and hl-sexp for lisp related modes
#+begin_src emacs-lisp :results silent
  (el-get 'sync (list "paredit" "hl-sexp"))

  (defun abaw/lisp-hook ()
    (eldoc-mode 1)
    (hl-sexp-mode 1)
    (paredit-mode 1))

  (mapc (lambda (mode-hook)
          (add-hook mode-hook 'abaw/lisp-hook))
        '(lisp-mode-hook emacs-lisp-mode-hook ielm-mode-hook))

  (add-hook 'minibuffer-setup-hook (lambda ()
                                     (when (eq this-command 'eval-expression)
                                         (paredit-mode 1))))
#+end_src

*** emacs lisp
#+begin_src emacs-lisp :results silent
  (el-get 'sync "auto-complete-emacs-lisp")
  (require 'auto-complete-emacs-lisp)
  (ac-emacs-lisp-init)
  (add-to-list 'ac-modes 'inferior-emacs-lisp-mode)
  (add-hook 'ielm-mode-hook 'ac-emacs-lisp-setup)
#+end_src

** haskell
#+begin_src emacs-lisp :results silent
(el-get 'sync "haskell-mode")
#+end_src


** python
#+begin_src emacs-lisp :results silent
  (el-get 'sync "python-mode")
  (require 'python-mode)
  (set-default 'py-shell-name "ipython")
#+end_src

* Per-host customization
** additional configuration for this host
#+begin_src emacs-lisp :results silent
  (let ((per-host-config (abaw/join-path abaw/host-dir "config.org")))
    (when (file-exists-p per-host-config)
      (org-babel-load-file per-host-config)))
#+end_src

** emacs customization file
#+begin_src emacs-lisp :results silent
  (setq custom-file (expand-file-name "custom.el" abaw/host-dir))
  (when (file-exists-p custom-file)
    (load-file custom-file))
#+end_src
* Start emacs server
#+begin_src emacs-lisp :results silent
  (server-start)
  (setenv "EDITOR" "emacsclient")
#+end_src
